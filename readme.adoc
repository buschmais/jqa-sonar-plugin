= jQAssistant SonarQube Plugin

This is the SonarQube plugin for jQAssistant integration.

== Requirements
* Java 7 or higher
* SonarQube 5.1.2
* Java project with jQAssistant setup

== Installation
* Copy the plugin (i.e. JAR file) to the `plugin/extensions` folder of the SonarQube installation
* (Re-)Start the SonarQube server

== Configuration
The plugin provides two rules that need to be activated for the quality profile of your project(s).

Invalid Concept::
  Concepts that are defined but could not be applied successfully (default severity: Minor).
Constraint Violation::
  Constraints that reported violations (default severity: Major).

Therefore the following steps need to be performed in the SonarQube UI (as administrator):

* Navigate to `Quality Profiles`
* Select your desired quality profile
* Activate the jQAssistant rules
** Open the view to manage the rules of the quality profile
** Search for inactive rules in the repository `jQAssistant` (by using the filters on the left side)
** Activate the desired rules
* Add your project to the quality profile (if not already done)
** Navigate back to the overview screen of the selected quality profile
** Select `Projects`
** Add your project

== Execution
In case of a Maven project with a jQAssistant setup the following steps need to be executed

`mvn install`::
  Build the project and execute scan and analysis by jQAssistant
`mvn sonar:sonar`::
  Run the SonarQube analysis.
  The sensor of the jQAssistant SonarQube plugin will evaluate the file `target/jqassistant/jqassistant-report.xml` and
  create issues for failed rules.

== Rules
In the following we're describing some best practises of the usage of jQAssistant in combination
with the Sonar-jQA plugin.

The following example describes a method invocation from a class of the persistence layer to a class
of the core layer.


[source]
MATCH
    (persistenceclass:Class:Persistence) -[:DECLARES]-> (persistencemethod:Method)
        -[i:INVOKES]->
    (coremethod:Method) <-[:DECLARES]- (coreclass:Class:Core)


We're now comparing three different examples of possible return values and their jQA report results which are
the base of processing new Sonar issues.

=== From jQA queries to Sonar issues
When you build you project with `mvn clean install` jQA will execute all the rules you provided and
generate the file `report.xml`.
This report is the base for the Sonar-jQA plugin to generate Sonar new issues.
The plugin processes the report and uses the first return value of jQA rule as the `primary column`
to generate the issues. All other return values where used to be appended to the Sonar issues
as some kind of additional information.
It's very recommended to put as much as information to your first return value to generate
meaningful Sonar issues.

In the following you can see three example of possible primary return values.


1.) RETURN persistenceclass.name

[soruce,xml]
    <result>
        <columns count="3">
            <column primary="true">persistenceclass.name</column>
        </columns>
        <rows count="1">
            <row>
                <column name="persistenceclass.name">
                    <value>AnyPersistenceClass</value>
                </column>
            </row>
        </rows>
    </result>

2.) RETURN coreclass

[soruce,xml]
    <result>
        <columns count="1">
            <column primary="true">coreclass</column>
        </columns>
        <rows count="1">
            <row>
                <column name="coreclass">
                    <element language="Java">Type</element>
                    <source name="org/jqassistant/example/core/AnyCoreClass.class"></source>
                    <value>org/jqassistant/example/core/InvokedCoreMethod</value>
                </column>
            </row>
        </rows>
    </result>

3.) RETURN i

[soruce,xml]
    <result>
        <columns count="1">
            <column primary="true">i</column>
        </columns>
        <rows count="1">
            <row>
              <column name="i">
                <element language="Java">MethodInvocation</element>
                <source name="/org/jqassistant/example/persistence/AnyPersictenceClass.class" line="64"></source>
                <value>org/jqassistant/example/persistence/AnyPersistcenceClass#java.util.List coreMethodInvocation(java.lang.Long), line 64</value>
              </column>
            </row>
        </rows>
    </result>

It's easy to see that the third variation is the one with the most information bundle.
In this case the return value is the whole relationship between the persistence and core class.
